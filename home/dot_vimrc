" ========= Plugins =========
call plug#begin('~/.vim/plugged')

" LSP-like IntelliSense
Plug 'neoclide/coc.nvim', {'branch': 'release'}

Plug 'fatih/vim-go'
Plug 'puremourning/vimspector'

Plug 'junegunn/fzf'
Plug 'junegunn/fzf.vim'

Plug 'tpope/vim-fugitive'
Plug 'airblade/vim-gitgutter'

Plug 'airblade/vim-rooter'

Plug 'mhinz/vim-startify'

Plug 'tpope/vim-commentary'

Plug 'vim-airline/vim-airline'
Plug 'vim-airline/vim-airline-themes'

Plug 'Konfekt/filepicker.vim'

Plug 'dunstontc/vim-vscode-theme'

call plug#end()

" ========= Basics =========
filetype plugin indent on
syntax on
colorscheme dark_plus
set nocompatible
set hidden
set number
set updatetime=300
set noundofile
set completeopt=menuone,noinsert,noselect
set wildmode=longest:full,full
set ignorecase smartcase incsearch hlsearch
set wrap
set tabstop=4
set shiftwidth=4
set expandtab
set autoindent
set smartindent
set linebreak
set termguicolors
set background=dark
set nobackup
set nowritebackup
set noswapfile
set autoread
set signcolumn=number
set balloondelay=250
set backspace=2
set timeoutlen=1000 ttimeoutlen=0
set showcmd
set splitbelow
set splitright
set relativenumber

set mouse=a
set ttymouse=sgr

let mapleader = ","

nnoremap <silent> <Tab>   :bnext<CR>
nnoremap <silent> <S-Tab> :bprevious<CR>
nmap <leader>o m`o<Esc>``
nmap <leader>O m`O<Esc>``
noremap <leader>p "+p
noremap <leader>P "+P
vnoremap Y "+y

tnoremap <Esc> <C-w>N

" ========= FZF mappings =========
nnoremap <leader>ff :Files<CR>
nnoremap <leader>fg :Rg<CR>
nnoremap <leader>fb :Buffers<CR>
nnoremap <leader>/ :BLines<CR>

" Make :Files show hidden files but ignore .git
let $FZF_DEFAULT_COMMAND = 'rg --files --hidden --follow -g "!.git/"'

" ========= Rooter (auto cd to repo root) =========
let g:rooter_patterns = ['go.work', 'go.mod', '.git', '.hg', '.svn']
let g:rooter_change_directory_for_non_project_files = 'current'
" Use global :cd so a single vim instance tracks one main project directory
let g:rooter_cd_cmd = 'cd'

" ========= Startify =========
let g:startify_change_to_dir = 0
let g:startify_session_autoload = 1
let g:startify_session_persistence = 1


function! s:SessionNameFromCwdFull() abort
  " 1) Normalize paths (strip trailing slashes)
  let path = substitute(fnamemodify(getcwd(), ':p'), '/\+$', '', '')
  let home = substitute(fnamemodify(expand('~'), ':p'), '/\+$', '', '')

  " 2) Make relative to $HOME if applicable
  if path[:len(home)-1] ==# home
    let rel = path[len(home):]
  else
    let rel = path
  endif

  " 3) Remove leading slash; handle CWD == HOME
  if rel =~ '^/' | let rel = rel[1:] | endif
  if empty(rel)  | let rel = 'home'   | endif

  let rel = substitute(rel, '^\.', 'dot_', '')

  " 4) Sanitize to a filename-friendly session name
  let name = substitute(rel, '[/\\: ]', '_', 'g')
  let name = substitute(name, '[^A-Za-z0-9_.-]', '_', 'g')
  return name
endfunction

command! SSavePath execute 'SSave ' . s:SessionNameFromCwdFull()

" ========= Coc =========
let g:coc_global_extensions = ['coc-json', 'coc-yaml', 'coc-snippets', 'coc-pairs']

inoremap <silent><expr> <CR> coc#pum#visible() ? coc#pum#confirm() : "\<CR>"
inoremap <silent><expr> <Tab>   coc#pum#visible() ? coc#pum#next(1)  : "\<Tab>"
inoremap <silent><expr> <S-Tab> coc#pum#visible() ? coc#pum#prev(1)  : "\<S-Tab>"

augroup GoCocKeys
  autocmd!
  autocmd FileType go nmap <buffer> gd <Plug>(coc-definition)
  autocmd FileType go nmap <buffer> gy <Plug>(coc-type-definition)
  autocmd FileType go nmap <buffer> gr <Plug>(coc-references)
  autocmd FileType go nmap <buffer> gi <Plug>(coc-implementation)
  autocmd FileType go nmap <buffer> <leader>rn <Plug>(coc-rename)
  autocmd FileType go nmap <buffer> <leader>ca <Plug>(coc-codeaction)
  autocmd FileType go nnoremap <buffer> K :call CocActionAsync('doHover')<CR>
augroup END

nnoremap <silent> [d <Plug>(coc-diagnostic-prev)
nnoremap <silent> ]d <Plug>(coc-diagnostic-next)

nnoremap <leader>sp :CocList outline<CR>
nnoremap <leader>t :CocList -I symbols<CR>

" Smart <CR>: confirm pum OR split pairs with indent OR normal Coc enter
inoremap <expr> <CR> coc#pum#visible() ? coc#pum#confirm() : <SID>SmartCR()

function! s:BetweenPair() abort
  let coln = col('.')
  if coln <= 1 | return 0 | endif
  let line = getline('.')
  if coln > len(line) | return 0 | endif
  let prev = line[coln-2]
  let next = line[coln-1]
  return ( (prev ==# '(' && next ==# ')')
        \ || (prev ==# '[' && next ==# ']')
        \ || (prev ==# '{' && next ==# '}') )
endfunction

function! s:SmartCR() abort
  if <SID>BetweenPair()
    " newline, then open a new line above the closer (properly indented)
    return "\<C-g>u\<CR>\<Esc>O"
  endif
  " default enter + Coc's on_enter hook
  return "\<C-g>u\<CR>\<C-r>=coc#on_enter()\<CR>"
endfunction

" ========= vimspector =========
let g:vimspector_enable_mappings = 'VISUAL_STUDIO'

" ========= vim-go (tools; disable its LSP) =========
let g:go_addtags_options = 'json=omitempty'
let g:go_addtags_transform = 'camelcase'
let g:go_fmt_command = 'gofumpt'
let g:go_imports_mode = 'goimports'

let g:go_auto_type_info = 0
let g:go_def_mapping_enabled = 0
let g:go_doc_keywordprg_enabled = 0
let g:go_doc_popup_window = 0
let g:go_fmt_autosave = 0
let g:go_gopls_enabled = 0
let g:go_highlight_fields = 1
let g:go_highlight_function_calls = 1
let g:go_highlight_functions = 1
let g:go_highlight_types = 1
let g:go_mod_fmt_autosave = 0

" ========= netrw quality-of-life =========
let g:netrw_banner = 0
let g:netrw_liststyle = 0
let g:netrw_winsize = 30
let g:netrw_keepdir = 0
let g:netrw_browse_split = 0
let g:netrw_list_hide = '\(^\|\s\s\)\zs\.\S\+'
let g:netrw_localcopydircmd = 'cp -r'
let g:netrw_localrmdir='rm -r'

nnoremap <leader>dd :Lexplore %:p:h<CR>
nnoremap <Leader>da :Lexplore<CR>

hi! link netrwMarkFile SpecialKey

function! NetrwMapping()
  nmap <buffer> H u
  nmap <buffer> h -^
  nmap <buffer> l <CR>
  nmap <buffer> . gh
  nmap <buffer> P <C-w>z
  nmap <buffer> L <CR>:Lexplore<CR>
  nmap <buffer> <leader>dd :Lexplore<CR>

  nmap <buffer> <Space> mf
  nmap <buffer> <M-Space> mF
  nmap <buffer> <leader><Tab> mu

  nmap <buffer> ff %:w<CR>:buffer #<CR>
  nmap <buffer> fe R
  nmap <buffer> fc mc
  nmap <buffer> fC mtmc
  nmap <buffer> fx mm
  nmap <buffer> fX mtmm
  nmap <buffer> f; mx
  nmap <buffer> fl :echo join(netrw#Expose("netrwmarkfilelist"), "\n")<CR>

  nmap <buffer> bb mb
  nmap <buffer> bd mB
  nmap <buffer> bl gb
endfunction

augroup netrw_mapping
  autocmd!
  autocmd filetype netrw call NetrwMapping()
augroup END

" ========= FileExplorer Hack =========
" calls FilePicker on a new dir instead of netrw
" see netrw configuration above just in case
augroup FileExplorer
  autocmd!
augroup END

augroup FilePickerHijack
  autocmd!
  autocmd VimEnter * if argc() == 1 && isdirectory(argv(0)) |
        \ call s:OpenDirWithPicker(argv(0)) |
        \ endif

  autocmd BufEnter * if &buftype == '' && isdirectory(expand('%:p')) |
        \ call s:OpenDirWithPicker(expand('%:p')) |
        \ endif
augroup END

function! s:OpenDirWithPicker(dir) abort
  let l:abs = fnamemodify(a:dir, ':p')
  execute 'cd' fnameescape(l:abs)
  if expand('%:p') ==# l:abs
    silent! bwipeout
  endif

  silent! FilePicker
endfunction

" ========= Airline =========
let g:airline#extensions#tabline#enabled = 1
let g:airline#extensions#tabline#buffer_nr_show = 1
let g:airline#extensions#tabline#show_buffers = 1
let g:airline_powerline_fonts = 1
let g:airline_theme='atomic'

" ========== Todo Highlights ==========
hi Todo guifg=White guibg=Orange
hi Note guifg=Red guibg=Yellow
hi Hack guifg=Black guibg=Green
hi Warn guifg=White guibg=Red
hi Kludge guifg=#ef42f5 guibg=Black

autocmd BufReadPost,BufNewFile * call matchadd('Todo', '\<TODO\>')
autocmd BufReadPost,BufNewFile * call matchadd('Note', '\<NOTE\>')
autocmd BufReadPost,BufNewFile * call matchadd('Hack', '\<HACK\>')
autocmd BufReadPost,BufNewFile * call matchadd('Warn', '\<WARN\>')
autocmd BufReadPost,BufNewFile * call matchadd('Kludge', '\<kludge\>')
